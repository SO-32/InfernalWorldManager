From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sam Turner <samt@thoriumcube.org>
Date: Tue, 10 Oct 2023 11:58:30 +0100
Subject: [PATCH] Add ChunkDataLoadTask


diff --git a/src/main/java/com/infernalsuite/iwm/level/ChunkDataLoadTask.java b/src/main/java/com/infernalsuite/iwm/level/ChunkDataLoadTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..d09352712c49f732520023c7218c782a4cb9dbf4
--- /dev/null
+++ b/src/main/java/com/infernalsuite/iwm/level/ChunkDataLoadTask.java
@@ -0,0 +1,121 @@
+package com.infernalsuite.iwm.level;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import com.infernalsuite.iwm.api.world.InfernalChunk;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.chunk.system.scheduling.ChunkLoadTask;
+import io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler;
+import io.papermc.paper.chunk.system.scheduling.GenericDataLoadTask;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.UpgradeData;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import org.slf4j.Logger;
+
+import java.util.function.Consumer;
+
+public final class ChunkDataLoadTask implements CommonLoadTask {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    private final ChunkTaskScheduler scheduler;
+    private final ServerLevel world;
+    private final int chunkX;
+    private final int chunkZ;
+    private Consumer<GenericDataLoadTask.TaskResult<ChunkAccess, Throwable>> onRun;
+
+    private PrioritisedExecutor.PrioritisedTask task;
+
+    private final ChunkLoadTask chunkLoadTask;
+
+    protected ChunkDataLoadTask(ChunkLoadTask chunkLoadTask, final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                final int chunkZ, final PrioritisedExecutor.Priority priority, final Consumer<GenericDataLoadTask.TaskResult<ChunkAccess, Throwable>> onRun) {
+        this.chunkLoadTask = chunkLoadTask;
+        this.scheduler = scheduler;
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.onRun = onRun;
+
+        this.task = this.scheduler.createChunkTask(this.chunkX, this.chunkZ, () -> {
+            try {
+                InfernalChunk chunk = this.world.infernalInstance.getChunk(this.chunkX, this.chunkZ);
+                this.onRun.accept(new GenericDataLoadTask.TaskResult<>(runOnMain(chunk), null));
+            } catch (Throwable e) {
+                LOGGER.error("ERROR", e);
+                this.onRun.accept(new GenericDataLoadTask.TaskResult<>(null, e));
+            }
+        }, priority);
+    }
+
+    private ChunkAccess getEmptyChunk() {
+        LevelChunkTicks<Block> blockLevelChunkTicks = new LevelChunkTicks<>();
+        LevelChunkTicks<Fluid> fluidLevelChunkTicks = new LevelChunkTicks<>();
+
+        return new ImposterProtoChunk(new LevelChunk(this.world, new ChunkPos(this.chunkX, this.chunkZ), UpgradeData.EMPTY, blockLevelChunkTicks, fluidLevelChunkTicks,
+                0L, null, null, null), true);
+    }
+
+    protected ChunkAccess runOnMain(final SlimeChunk data) {
+        final PoiChunk poiChunk = this.chunkLoadTask.chunkHolder.getPoiChunk();
+        if (poiChunk == null) {
+            LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this.toString());
+        } else {
+            poiChunk.load();
+        }
+
+        // have tasks to run (at this point, it's just the POI consistency checking)
+        try {
+            //                if (data.tasks != null) {
+            //                    for (int i = 0, len = data.tasks.size(); i < len; i) {
+            //                        data.tasks.poll().run();
+            //                    }
+            //                }
+
+            LevelChunk chunk = this.world.slimeInstance.promote(chunkX, chunkZ, data);
+
+            return new ImposterProtoChunk(chunk, false);
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr2) {
+            LOGGER.error("Failed to parse main tasks for task " + this.toString() + ", chunk data will be lost", thr2);
+            return this.getEmptyChunk();
+        }
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.task.getPriority();
+    }
+
+    @Override
+    public void setPriority(PrioritisedExecutor.Priority priority) {
+        this.task.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(PrioritisedExecutor.Priority priority) {
+        this.task.raisePriority(priority);
+    }
+
+    @Override
+    public void lowerPriority(PrioritisedExecutor.Priority priority) {
+        this.task.lowerPriority(priority);
+    }
+
+    @Override
+    public boolean cancel() {
+        return this.task.cancel();
+    }
+
+    public boolean schedule(boolean schedule) {
+        this.scheduler.scheduleChunkTask(chunkX, chunkZ, this.task::execute);
+        return true;
+    }
+}
